"""
    Example script to integrate a given matrix element generated with the pyout madgraph plugin
    In order to run this script, vegasflow needs to be installed

    This script is WIP and is not autogenerated with the rest of the pyout output, to run first generate
    some process with madraph

    ```
        ~$ mg5_aMC
        MG5_aMC>generate g g > t t~
        MG5_aMC>output pyout vegasflow_example
    ```

    which will generate a vegasflow_example folder with all the required files.
    Link that folder to this script in the first line below (`matrix_elm_folder`).
"""
matrix_elm_folder = "../../mg5amcnlo/bin/vegasflow_example/"

import os
import numpy as np
import vegasflow
os.environ["CUDA_VISIBLE_DEVICES"] = ""
vegasflow.run_eager(True) # so we don't have to worry for now abut tf 
import tensorflow as tf

######### Import the matrix elements and the necessary models
all_matrices = []
all_models = []
base_model = "models/sm"
# This piece of code loops over all matrix_XXXX.py files in the folder generated by the pyout script
# and loads them to the all_matrices, together with their corresponding models
# at the end it cleans all paths _assuming_ all necessary modules have been loaded
# during the instantiation of the matrix element this should be safe
import sys
import glob
import copy
import importlib.util
import re
re_name = re.compile("\w{3,}")
original_path = copy.copy(sys.path)
sys.path.insert(0, matrix_elm_folder)
for matrix_file in glob.glob(f"{matrix_elm_folder}/matrix_*.py"):
    matrix_name = re_name.findall(matrix_file)[-1]
    class_name = matrix_name.capitalize()
    # This seems unnecesarily complicated to load a class from a file by anyway
    module_spec = importlib.util.spec_from_file_location(matrix_name, matrix_file)
    module = importlib.util.module_from_spec(module_spec)
    module_spec.loader.exec_module(module)
    # Now with access to the model, fill the list of matrices (with the object instantiated)
    # and the list of models attending to the root_path in the module
    all_matrices.append(getattr(module, class_name)())
    # After loading the module we have access to the internals of said module
    # which includes import_ufo and root_path
    root_path = getattr(module, "root_path")
    import_ufo = getattr(module, "import_ufo")
    model = import_ufo.import_model(f"{root_path}/{base_model}")
    all_models.append(model)

# Clean the path
sys.path = original_path
# Uncomment loop below to run a test over the loaded matrix elements
# for matrix, model in zip(all_matrices, all_models):
#     # Generate a random momentum according to the number of external particles
#     # (likely unphysical!)
#     momenta = np.random.rand(matrix.nexternal,4)*100
#     print(f"Result: {matrix.smatrix(momenta, model):.5f}")
#######################################################

# Very complicated function that generates phase space momenta from the input random points
# the number of particles in the system and their masses
def phasespace_generator(xrand, nparticles):
    """ Takes as input an array of nevent x ndim random points and outputs
    an array of momenta (nevents x nparticles x 4)
    """
    return vegasflow.float_me(tf.random.uniform((xrand.shape[0],nparticles, 4))*1e4)

# Minimal working exaple of cross section calculation with vegasflow
def cross_section(xrand, **kwargs):
    # IRL we would be gruping matrices by nparticles
    res = 0.0
    for matrix, model in zip(all_matrices, all_models):
        all_ps = phasespace_generator(xrand, matrix.nexternal)
        for ps in all_ps.numpy(): # when in eager mode, better to loop over numpy
            # TODO the matrix element should be made to take values in parallel!
            res += matrix.smatrix(ps, model)
    return vegasflow.float_me(res/tf.reduce_sum(xrand))

n_dim = 2
n_iter = 5
n_events = 1000
result = vegasflow.vegas_wrapper(cross_section, n_dim, n_iter, n_events)
