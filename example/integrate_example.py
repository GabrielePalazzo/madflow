"""
    Example script to integrate a given matrix element generated with the pyout madgraph plugin
    In order to run this script, vegasflow needs to be installed

    This script is WIP and is not autogenerated with the rest of the pyout output, to run first generate
    some process with madraph

    ```
        ~$ mg5_aMC
        MG5_aMC>generate g g > t t~
        MG5_aMC>output pyout vegasflow_example
    ```

    which will generate a vegasflow_example folder with all the required files.
    Link that folder to this script in the first line below (`matrix_elm_folder`).
"""
matrix_elm_folder = "../../vegasflow_example/"

import os
import numpy as np
from time import time as tm
import vegasflow
os.environ["CUDA_VISIBLE_DEVICES"] = ""
vegasflow.run_eager(True) # so we don't have to worry for now abut tf 
import tensorflow as tf

from parallel_rambo import parallel_rambo

COM_SQRTS = 7e3

######### Import the matrix elements and the necessary models
all_matrices = []
all_matrices_flow = []
model = None
base_model = "models/sm"
# This piece of code loops over all matrix_XXXX.py files in the folder generated by the pyout script
# and loads them to the all_matrices, together with their corresponding model
# at the end it cleans all paths _assuming_ all necessary modules have been loaded
# during the instantiation of the matrix element this should be safe
import sys
import glob
import copy
import importlib.util
import re
re_name = re.compile("\w{3,}")
original_path = copy.copy(sys.path)
sys.path.insert(0, matrix_elm_folder)
for matrix_file in glob.glob(f"{matrix_elm_folder}/matrix_*.py"):
    matrix_name = re_name.findall(matrix_file)[-1]
    class_name = matrix_name.capitalize()
    # This seems unnecesarily complicated to load a class from a file by anyway
    module_spec = importlib.util.spec_from_file_location(matrix_name, matrix_file)
    module = importlib.util.module_from_spec(module_spec)
    module_spec.loader.exec_module(module)
    # Now with access to the module, fill the list of matrices (with the object instantiated)
    all_matrices.append(getattr(module, class_name)())

# Use the last module to load its model (all matrices should be using the same one!)
root_path = getattr(module, "root_path")
import_ufo = getattr(module, "import_ufo")
model = import_ufo.import_model(f"{root_path}/{base_model}")
# import parameters useful for smatrix calculation
for matrix_file in glob.glob(f"example/matrix*.py"):
    print("This is going to be loaded ", matrix_file)
    matrix_name = re_name.findall(matrix_file)[-1]
    class_name = matrix_name.capitalize()
    # This seems unnecesarily complicated to load a class from a file by anyway
    module_spec = importlib.util.spec_from_file_location(matrix_name, matrix_file)
    module = importlib.util.module_from_spec(module_spec)
    module_spec.loader.exec_module(module)
    # Now with access to the module, fill the list of matrices (with the object instantiated)
    all_matrices_flow.append(getattr(module, class_name)())
from matrixflow_1_gg_ttx import get_model_param
model_params = get_model_param(model)


# Clean the path
sys.path = original_path
# Uncomment loop below to run a test over the loaded matrix elements
for matrix in all_matrices:
    # Generate a random momentum according to the number of external particles
    # (likely unphysical!)
    momenta = np.random.rand(matrix.nexternal,4)*100
    print(f"Result: {matrix.smatrix(momenta, model):.5f}")
#######################################################

# Very complicated function that generates phase space momenta from the input random points
# the number of particles in the system and their masses
def phasespace_generator(xrand, nparticles):
    """ Takes as input an array of nevent x ndim random points and outputs
    an array of momenta (nevents x nparticles x 4)
    """
    return parallel_rambo(xrand, 4, COM_SQRTS)


# Minimal working exaple of cross section calculation with vegasflow
def cross_section(xrand, **kwargs):
    # IRL we would be gruping matrices by nparticles
    res = 0.0
    for matrix in all_matrices:
        all_ps, wt = phasespace_generator(xrand, matrix.nexternal)
        for ps in all_ps.numpy(): # when in eager mode, better to loop over numpy
            res += matrix.smatrix(ps**2/1e4, model)
    return wt*vegasflow.float_me(res/tf.reduce_sum(xrand))


# Minimal working example of tf vectorized cross section function
def cross_section_flow(xrand, **kwargs):
    # IRL we would be gruping matrices by nparticles
    res = vegasflow.float_me([0.0])
    for matrixflow in all_matrices_flow:
        all_ps, wt = phasespace_generator(xrand, matrix.nexternal)
        smatrices = matrixflow.smatrix(all_ps**2/1e4, *model_params)
        res += tf.reduce_sum(smatrices)
    return wt*vegasflow.float_me(res/tf.reduce_sum(xrand))

n_dim = 16 
# For now we have (4 particles -> 16 random numbers)
# they are also massless so results will be unphysical anyway
n_iter = 5
n_events = 1000

start = tm()
result = vegasflow.vegas_wrapper(cross_section, n_dim, n_iter, n_events)
print(f"Vegasflow integration with original mg5 smatrix function done in: {tm()-start} s")

# TODO: check that the vectorized smatrix gives the same results as the original approach
start = tm()
result = vegasflow.vegas_wrapper(cross_section_flow, n_dim, n_iter, n_events)
print(f"Vegasflow integration with tf vectorized smatrix function done in: {tm()-start} s")
